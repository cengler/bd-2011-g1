\section{Conclusiones}

Con respecto al algoritmo de \fs, vemos que ninguna de las estrategias de reemplazo de páginas es mejor a otra.
\newline
Pero uno puede observar resultados interesantes cuando se necesita recorrer más de una vez la traza, dado que ahora hay oportunidad de cachear páginas pedidas anteriormente.
\newline
Para el caso de dos lecturas sucesivas sobre la misma traza podemos considerar dos escenarios:
\begin{itemize}
 \item	\textbf{La cantidad de frames en buffer es menor a la cantidad de páginas pedidas}: la única estrategia que tiene Hit-Rate mayor a 0 es MRU. FIFO y LRU cuando necesitan alojar una nueva página empiezan desalojando la primera en ser almacenada y este comportamiento impide reaprovechar esas páginas en la segunda lectura de la traza.
 \item	\textbf{La cantidad de frames en buffer en mayor o igual a la cantidad de páginas pedidas}: en este escenario las tres estrategias muestran un HitRate del 50\% dado que si bien en la primera lectura no tienen ninguna página en buffer, para la segunda no tuvieron que desalojar ninguna(son todos hits).
\end{itemize}

En cuanto al algoritmo BNLJ, podemos considerar los siguientes escenarios:
\begin{itemize}
  \item Las páginas de R pueden ser cacheadas en memoria en su totalidad dejando por lo menos dos frames de memoria libres,uno para un bloque de S y otro para el resultado del JOIN. Este caso no es muy interesante, ya que con cualquier algoritmo de reemplazo el hit-rate es cero. Esto se da porque tengemos cacheado R completo y lo que necesitamos ir iterando es el bloque de S contra el cuál cruzamos los bloques de R. Es decir, en la primer iteración cruzamos todos los bloques de R contra el primero de S y obtenemos un miss, luego paso a cargar en memoria en segundo bloque de S y en caso de tener que reemplazar el único bloque que hizo release fue el bloque anterior de S y volvemos a obtener otro miss, y así sucesivamente hasta iterar sobre todo S.
  \item La totalidad de las páginas de R no pueden ser cacheadas en memoria y además tenemos dos frames de memoria libres, uno para un bloque de S y otro para el resultado del JOIN. 
  \item TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
\end{itemize}

En cuanto al INLJ con un índice B+ Clustered,
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO.

En cuanto al INLJ con un índice B+ UnClustered, 
  TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
